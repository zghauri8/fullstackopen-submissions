{"version":3,"names":["_toArray","require","_toPropertyKey","_decorate","decorators","factory","superClass","mixins","api","_getDecoratorsApi","i","length","r","initialize","O","initializeInstanceElements","decorated","elements","decorateClass","_coalesceClassElements","d","map","_createElementDescriptor","initializeClassElements","F","runClassFinishers","finishers","elementsDefinitionOrder","forEach","kind","element","placement","defineClassElement","proto","prototype","receiver","descriptor","initializer","enumerable","writable","configurable","value","call","Object","defineProperty","key","newElements","placements","static","own","addElementPlacement","_hasDecorators","push","elementFinishersExtras","decorateElement","apply","extras","result","decorateConstructor","silent","keys","indexOf","TypeError","splice","elementObject","fromElementDescriptor","elementFinisherExtras","toElementFinisherExtras","finisher","newExtras","j","obj","fromClassDescriptor","elementsAndFinisher","toClassDescriptor","undefined","k","desc","Symbol","toStringTag","toElementDescriptors","elementObjects","toArray","toElementDescriptor","disallowProperty","String","toPropertyKey","assign","_optionalCallableProperty","constructor","newConstructor","name","objectType","def","get","set","_coalesceGetterSetter","other","isSameElement","find","_isDataDescriptor","ReferenceError"],"sources":["../../src/helpers/decorate.js"],"sourcesContent":["/* @minVersion 7.1.5 */\n\n// TODO: Only Babel 7\n\nimport toArray from \"toArray\";\nimport toPropertyKey from \"toPropertyKey\";\n\n/*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n/*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n/*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n// ClassDefinitionEvaluation (Steps 26-*)\nexport default function _decorate(\n  decorators /*: ClassDecorator[] */,\n  factory /*: ClassFactory */,\n  superClass /*: ?Class<*> */,\n  mixins /*: ?Array<Function> */,\n) /*: Class<*> */ {\n  var api = _getDecoratorsApi();\n  if (mixins) {\n    for (var i = 0; i < mixins.length; i++) {\n      api = mixins[i](api);\n    }\n  }\n\n  var r = factory(function initialize(O) {\n    api.initializeInstanceElements(O, decorated.elements);\n  }, superClass);\n  var decorated = api.decorateClass(\n    _coalesceClassElements(r.d.map(_createElementDescriptor)),\n    decorators,\n  );\n\n  api.initializeClassElements(r.F, decorated.elements);\n\n  return api.runClassFinishers(r.F, decorated.finishers);\n}\n\nfunction _getDecoratorsApi() {\n  _getDecoratorsApi = function () {\n    return api;\n  };\n\n  var api = {\n    elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n    // InitializeInstanceElements\n    initializeInstanceElements: function (\n      /*::<C>*/ O /*: C */,\n      elements /*: ElementDescriptor[] */,\n    ) {\n      [\"method\", \"field\"].forEach(function (kind) {\n        elements.forEach(function (element /*: ElementDescriptor */) {\n          if (element.kind === kind && element.placement === \"own\") {\n            this.defineClassElement(O, element);\n          }\n        }, this);\n      }, this);\n    },\n\n    // InitializeClassElements\n    initializeClassElements: function (\n      /*::<C>*/ F /*: Class<C> */,\n      elements /*: ElementDescriptor[] */,\n    ) {\n      var proto = F.prototype;\n\n      [\"method\", \"field\"].forEach(function (kind) {\n        elements.forEach(function (element /*: ElementDescriptor */) {\n          var placement = element.placement;\n          if (\n            element.kind === kind &&\n            (placement === \"static\" || placement === \"prototype\")\n          ) {\n            var receiver = placement === \"static\" ? F : proto;\n            this.defineClassElement(receiver, element);\n          }\n        }, this);\n      }, this);\n    },\n\n    // DefineClassElement\n    defineClassElement: function (\n      /*::<C>*/ receiver /*: C | Class<C> */,\n      element /*: ElementDescriptor */,\n    ) {\n      var descriptor /*: PropertyDescriptor */ = element.descriptor;\n      if (element.kind === \"field\") {\n        var initializer = element.initializer;\n        descriptor = {\n          enumerable: descriptor.enumerable,\n          writable: descriptor.writable,\n          configurable: descriptor.configurable,\n          value: initializer === void 0 ? void 0 : initializer.call(receiver),\n        };\n      }\n      Object.defineProperty(receiver, element.key, descriptor);\n    },\n\n    // DecorateClass\n    decorateClass: function (\n      elements /*: ElementDescriptor[] */,\n      decorators /*: ClassDecorator[] */,\n    ) /*: ElementsFinishers */ {\n      var newElements /*: ElementDescriptor[] */ = [];\n      var finishers /*: ClassFinisher[] */ = [];\n      var placements /*: Placements */ = {\n        static: [],\n        prototype: [],\n        own: [],\n      };\n\n      elements.forEach(function (element /*: ElementDescriptor */) {\n        this.addElementPlacement(element, placements);\n      }, this);\n\n      elements.forEach(function (element /*: ElementDescriptor */) {\n        if (!_hasDecorators(element)) return newElements.push(element);\n\n        var elementFinishersExtras /*: ElementFinishersExtras */ =\n          this.decorateElement(element, placements);\n        newElements.push(elementFinishersExtras.element);\n        newElements.push.apply(newElements, elementFinishersExtras.extras);\n        finishers.push.apply(finishers, elementFinishersExtras.finishers);\n      }, this);\n\n      if (!decorators) {\n        return { elements: newElements, finishers: finishers };\n      }\n\n      var result /*: ElementsFinishers */ = this.decorateConstructor(\n        newElements,\n        decorators,\n      );\n      finishers.push.apply(finishers, result.finishers);\n      result.finishers = finishers;\n\n      return result;\n    },\n\n    // AddElementPlacement\n    addElementPlacement: function (\n      element /*: ElementDescriptor */,\n      placements /*: Placements */,\n      silent /*: boolean */,\n    ) {\n      var keys = placements[element.placement];\n      if (!silent && keys.indexOf(element.key) !== -1) {\n        throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n      }\n      keys.push(element.key);\n    },\n\n    // DecorateElement\n    decorateElement: function (\n      element /*: ElementDescriptor */,\n      placements /*: Placements */,\n    ) /*: ElementFinishersExtras */ {\n      var extras /*: ElementDescriptor[] */ = [];\n      var finishers /*: ClassFinisher[] */ = [];\n\n      for (\n        var decorators = element.decorators, i = decorators.length - 1;\n        i >= 0;\n        i--\n      ) {\n        // (inlined) RemoveElementPlacement\n        var keys = placements[element.placement];\n        keys.splice(keys.indexOf(element.key), 1);\n\n        var elementObject /*: ElementObjectInput */ =\n          this.fromElementDescriptor(element);\n        var elementFinisherExtras /*: ElementFinisherExtras */ =\n          this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n        element = elementFinisherExtras.element;\n        this.addElementPlacement(element, placements);\n\n        if (elementFinisherExtras.finisher) {\n          finishers.push(elementFinisherExtras.finisher);\n        }\n\n        var newExtras /*: ElementDescriptor[] | void */ =\n          elementFinisherExtras.extras;\n        if (newExtras) {\n          for (var j = 0; j < newExtras.length; j++) {\n            this.addElementPlacement(newExtras[j], placements);\n          }\n          extras.push.apply(extras, newExtras);\n        }\n      }\n\n      return { element: element, finishers: finishers, extras: extras };\n    },\n\n    // DecorateConstructor\n    decorateConstructor: function (\n      elements /*: ElementDescriptor[] */,\n      decorators /*: ClassDecorator[] */,\n    ) /*: ElementsFinishers */ {\n      var finishers /*: ClassFinisher[] */ = [];\n\n      for (var i = decorators.length - 1; i >= 0; i--) {\n        var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n        var elementsAndFinisher /*: ElementsFinisher */ =\n          this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n        if (elementsAndFinisher.finisher !== undefined) {\n          finishers.push(elementsAndFinisher.finisher);\n        }\n\n        if (elementsAndFinisher.elements !== undefined) {\n          elements = elementsAndFinisher.elements;\n\n          for (var j = 0; j < elements.length - 1; j++) {\n            for (var k = j + 1; k < elements.length; k++) {\n              if (\n                elements[j].key === elements[k].key &&\n                elements[j].placement === elements[k].placement\n              ) {\n                throw new TypeError(\n                  \"Duplicated element (\" + elements[j].key + \")\",\n                );\n              }\n            }\n          }\n        }\n      }\n\n      return { elements: elements, finishers: finishers };\n    },\n\n    // FromElementDescriptor\n    fromElementDescriptor: function (\n      element /*: ElementDescriptor */,\n    ) /*: ElementObject */ {\n      var obj /*: ElementObject */ = {\n        kind: element.kind,\n        key: element.key,\n        placement: element.placement,\n        descriptor: element.descriptor,\n      };\n\n      var desc = {\n        value: \"Descriptor\",\n        configurable: true,\n      };\n      Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n      if (element.kind === \"field\") obj.initializer = element.initializer;\n\n      return obj;\n    },\n\n    // ToElementDescriptors\n    toElementDescriptors: function (\n      elementObjects /*: ElementObject[] */,\n    ) /*: ElementDescriptor[] */ {\n      if (elementObjects === undefined) return;\n      return toArray(elementObjects).map(function (elementObject) {\n        var element = this.toElementDescriptor(elementObject);\n        this.disallowProperty(\n          elementObject,\n          \"finisher\",\n          \"An element descriptor\",\n        );\n        this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n        return element;\n      }, this);\n    },\n\n    // ToElementDescriptor\n    toElementDescriptor: function (\n      elementObject /*: ElementObject */,\n    ) /*: ElementDescriptor */ {\n      var kind = String(elementObject.kind);\n      if (kind !== \"method\" && kind !== \"field\") {\n        throw new TypeError(\n          'An element descriptor\\'s .kind property must be either \"method\" or' +\n            ' \"field\", but a decorator created an element descriptor with' +\n            ' .kind \"' +\n            kind +\n            '\"',\n        );\n      }\n\n      var key = toPropertyKey(elementObject.key);\n\n      var placement = String(elementObject.placement);\n      if (\n        placement !== \"static\" &&\n        placement !== \"prototype\" &&\n        placement !== \"own\"\n      ) {\n        throw new TypeError(\n          'An element descriptor\\'s .placement property must be one of \"static\",' +\n            ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n            ' with .placement \"' +\n            placement +\n            '\"',\n        );\n      }\n\n      var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n      this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n      var element /*: ElementDescriptor */ = {\n        kind: kind,\n        key: key,\n        placement: placement,\n        descriptor: Object.assign({}, descriptor),\n      };\n\n      if (kind !== \"field\") {\n        this.disallowProperty(\n          elementObject,\n          \"initializer\",\n          \"A method descriptor\",\n        );\n      } else {\n        this.disallowProperty(\n          descriptor,\n          \"get\",\n          \"The property descriptor of a field descriptor\",\n        );\n        this.disallowProperty(\n          descriptor,\n          \"set\",\n          \"The property descriptor of a field descriptor\",\n        );\n        this.disallowProperty(\n          descriptor,\n          \"value\",\n          \"The property descriptor of a field descriptor\",\n        );\n\n        element.initializer = elementObject.initializer;\n      }\n\n      return element;\n    },\n\n    toElementFinisherExtras: function (\n      elementObject /*: ElementObject */,\n    ) /*: ElementFinisherExtras */ {\n      var element /*: ElementDescriptor */ =\n        this.toElementDescriptor(elementObject);\n      var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n        elementObject,\n        \"finisher\",\n      );\n      var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n        elementObject.extras,\n      );\n\n      return { element: element, finisher: finisher, extras: extras };\n    },\n\n    // FromClassDescriptor\n    fromClassDescriptor: function (\n      elements /*: ElementDescriptor[] */,\n    ) /*: ClassObject */ {\n      var obj = {\n        kind: \"class\",\n        elements: elements.map(this.fromElementDescriptor, this),\n      };\n\n      var desc = { value: \"Descriptor\", configurable: true };\n      Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n      return obj;\n    },\n\n    // ToClassDescriptor\n    toClassDescriptor: function (\n      obj /*: ClassObject */,\n    ) /*: ElementsFinisher */ {\n      var kind = String(obj.kind);\n      if (kind !== \"class\") {\n        throw new TypeError(\n          'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n            ' created a class descriptor with .kind \"' +\n            kind +\n            '\"',\n        );\n      }\n\n      this.disallowProperty(obj, \"key\", \"A class descriptor\");\n      this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n      this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n      this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n      this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n      var finisher = _optionalCallableProperty(obj, \"finisher\");\n      var elements = this.toElementDescriptors(obj.elements);\n\n      return { elements: elements, finisher: finisher };\n    },\n\n    // RunClassFinishers\n    runClassFinishers: function (\n      constructor /*: Class<*> */,\n      finishers /*: ClassFinisher[] */,\n    ) /*: Class<*> */ {\n      for (var i = 0; i < finishers.length; i++) {\n        var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n        if (newConstructor !== undefined) {\n          // NOTE: This should check if IsConstructor(newConstructor) is false.\n          if (typeof newConstructor !== \"function\") {\n            throw new TypeError(\"Finishers must return a constructor.\");\n          }\n          constructor = newConstructor;\n        }\n      }\n      return constructor;\n    },\n\n    disallowProperty: function (obj, name, objectType) {\n      if (obj[name] !== undefined) {\n        throw new TypeError(\n          objectType + \" can't have a .\" + name + \" property.\",\n        );\n      }\n    },\n  };\n\n  return api;\n}\n\n// ClassElementEvaluation\nfunction _createElementDescriptor(\n  def /*: ElementDefinition */,\n) /*: ElementDescriptor */ {\n  var key = toPropertyKey(def.key);\n\n  var descriptor /*: PropertyDescriptor */;\n  if (def.kind === \"method\") {\n    descriptor = {\n      value: def.value,\n      writable: true,\n      configurable: true,\n      enumerable: false,\n    };\n  } else if (def.kind === \"get\") {\n    descriptor = { get: def.value, configurable: true, enumerable: false };\n  } else if (def.kind === \"set\") {\n    descriptor = { set: def.value, configurable: true, enumerable: false };\n  } else if (def.kind === \"field\") {\n    descriptor = { configurable: true, writable: true, enumerable: true };\n  }\n\n  var element /*: ElementDescriptor */ = {\n    kind: def.kind === \"field\" ? \"field\" : \"method\",\n    key: key,\n    placement: def.static\n      ? \"static\"\n      : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n    descriptor: descriptor,\n  };\n  if (def.decorators) element.decorators = def.decorators;\n  if (def.kind === \"field\") element.initializer = def.value;\n\n  return element;\n}\n\n// CoalesceGetterSetter\nfunction _coalesceGetterSetter(\n  element /*: ElementDescriptor */,\n  other /*: ElementDescriptor */,\n) {\n  if (element.descriptor.get !== undefined) {